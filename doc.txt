PACKAGE DOCUMENTATION

package vec
    import "vec"



FUNCTIONS

func Arange(start float64, stop float64, N int) []float64

func Fold(f BiMathop, vec []float64) float64
    Canonical foldl - folds from vec[0] to vec[n]

func Integral(f Mathop, a float64, b float64) (out float64, conv bool)
    Performs Romberg integration on a Mathop

    Returns the integral evaluated from 'a' to 'b', and convergence.
    Supports (+/-)Inf as bounds.

    If conv = false, the integral did not converge with If conv = true, the
    integral is accurate to at least 15 decimal places.

func MPmap(fm Mathop, arr []float64)

	Massively Parallel Function-Slice Mapping
    Should be used for mapping 'expensive' functions onto short(ish) arrays
    in-place. Creates as many goroutines as there are floats in the array,
    so this bogs down for long arrays.

func NewSem(N int) semaphore

func PPmap(fm Mathop, arr []float64)

	Partitioned Funtion->Slice Mapping
    Maps 'fm()' onto each member of 'arr' in-place Uses 'NumCPU()'
    independent (non-load-balanced) goroutines

func PVecOperation(f BiMathop, arrOne []float64, arrTwo []float64) []float64

	Parallel Vector Operation
    - Creates a new slice from two other slices according to 'f()' - Uses
    NumCPU() goroutines for workload partioning (defaults to 2)

func Smap(fm Mathop, arr []float64, start int, end int)

	Iterative Function->Slice Mapping
    Maps a fuction onto an array on the values from 'start' to 'end'
    (typically '0' to 'len(arr)') No concurrency


TYPES

type BiMathop func(float64, float64) float64
    BiMathop - Bivariate math function



type BiVariateData struct {
    Xs []float64
    Ys []float64
    // contains filtered or unexported fields
}
    Struct for bivariate data (xs, ys)


func MakeBiVariateData(xs []float64, ys []float64) *BiVariateData
    Convert separate 'xs' and 'ys' arrays into a BiVariateData object

    -- 'xs' and 'ys' should be the same length -- sorts data by x-value
    automatically

    NOTE: sorting is done on slices, which means that 'xs' and 'ys' may be
    changed by calling this function


func (b *BiVariateData) Len() int
    Len for Sort interface

func (b *BiVariateData) Less(i, j int) bool
    Less for Sort interface

func (b *BiVariateData) Sort()
    Sorts b by ascending x value

func (b *BiVariateData) Swap(i, j int)
    Swap for Sort interface

func (b *BiVariateData) XY(n int) (x, y float64)
    Implement XYer interface for plotinum.plotter


type Condenser func([]float64) float64
    Condenser - turns an array into a single element



type CubicSplineInterpolation struct {
    // contains filtered or unexported fields
}
    CubicSplineInterpolation type def points to a BiVariateData container
    and contains an array of coefficients used for evaluating the
    interpolation, its derivatives, and its definite integral


func CubicSpline(d BiVariateData) CubicSplineInterpolation
    Default constructor for CubicSplineInterpolation Returns a fully-formed
    CubicSplineInterpolation from the data containe in 'd'

    *Note: this is a 'natural' cubic spline (meaning that points evaluated
    outside the data endpoints are extrapolated linearly)

    Feeds values to getCubicSplinCoeffs() that are equivalent to the
    right-hand side of the matrix equation (18) referenced in:
    http://mathworld.wolfram.com/CubicSpline.html


func (s CubicSplineInterpolation) DDF(x float64) float64
    Second derivative evaluated at 'x'

func (s CubicSplineInterpolation) DF(x float64) float64
    First derivative of interpolated data evaluated at 'x'

func (s CubicSplineInterpolation) F(x float64) float64
    Returns the interpolated value of 'x' on the data pointed to by 's'

func (s CubicSplineInterpolation) Integral(a float64, b float64) float64
    Returns the definite integral of a cubic spline evaluated from 'a' to
    'b'

    *Note: 'a' and 'b' must be rational (can't be +/-Inf -- will return NaN)


type FtBiMathop func(float64, float64) chan float64
    FtBiMathop - a future BiMathop (returned on a channel)


func MakeFtBiMathop(f BiMathop) FtBiMathop
    Makes a future from a BiMathop; returns a channel



type FtCondenser func([]float64) chan float64
    FtCondenser - a future Condenser (returned on a channel)



type FtLinop func([]float64) chan []float64
    FtLinop - a future Linop (returned on a channel)


func MakeFtLinop(f Linop) FtLinop
    Makes a future from a Linop; returns a channel



type FtMathop func(float64) chan float64
    FtMathop - a future Mathop (returned on a channel)


func MakeFtMathop(f Mathop) FtMathop
    MakeFtMathop - makes a future from a Mathop



type Linop func([]float64) []float64
    Linop - takes an array, yields an array of the same size



type Mathop func(float64) float64
    Mathop - Univariate math function



type Vecop func([]float64, []float64) []float64
    Vecop - operates on two arrays of the same size to yield a new array




